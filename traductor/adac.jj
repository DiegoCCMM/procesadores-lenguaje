 options {
   IGNORE_CASE = true;
   COMMON_TOKEN_ACTION = false;
   DEBUG_PARSER = true;
}

PARSER_BEGIN(adac)
package traductor;

import traductor.Token;
import lib.attributes.*;
import lib.symbolTable.*;
import lib.symbolTable.exceptions.*;
import lib.errores.*;

public class adac {

    SymbolTable tabla_simbolos = SymbolTable();

    public static void main(String [] args)
  {
    adac parser;
    try
    {
      if (args.length == 0)
      { //entrada desde stdin
        parser = new adac(System.in);
        System.out.println("Leyendo de la entrada estandar...");
      }
      else
      { //entrada desde fichero en args[0]
        parser = new adac(new java.io.FileInputStream(args [0]));
      }
      parser.programa(); //invoca simbolo inicial de la gramatica
    }
    catch (java.io.FileNotFoundException e) {
      System.err.println("Fichero " + args [0] + " no encontrado.");
    }
    catch (TokenMgrError e)    {
      errorLexico(token);
    }
    catch(ParseException e) {      	
		//errorSintactico(e);
   }
   System.out.println("FIN");
  }

  static void errorLexico(Token t) {
    System.err.println("ERROR L�XICO (" + SimpleCharStream.getBeginLine() + 
    ", " + SimpleCharStream.getBeginColumn() + "): s�mbolo no reconocido: <" + 
    SimpleCharStream.GetImage().charAt(adacTokenManager.curLexState) + ">");
  }


  static void errorSintactico(ParseException e){
    String msg ="ERROR SINT�CTICO (" + e.currentToken.next.beginLine + ", " + e.currentToken.next.beginColumn
     + "): encontrado: <" + e.currentToken.next.image + "> Se esperaba:  ";
     for(int i=0; i< e.expectedTokenSequences.length; i++) {
		msg+="  " + e.tokenImage[e.expectedTokenSequences[i][0]];
     }
    System.err.println(msg);
  }

  static void panic_mode(int kind) {
    Token t = adac.getNextToken();
    while (token.kind != kind && token.kind != EOF)
    {
      token = adac.getNextToken();
    }
    String error_msg = "PANIC MODE (<" + t.beginLine + ", " + 
    t.beginColumn + ">) : ignorando entrada hasta ";
    if (kind == tEND) { 
    	error_msg += " [end]";
  	}else {  
   		 error_msg += " [;]";
	}	
    System.err.println(error_msg);
  }


}
PARSER_END(adac)

TOKEN_MGR_DECLS: {
  
	static void infoLexico(Token t,String nombre) {
	  System.out.println("("+ t.beginLine+","+t.beginColumn+"): " + nombre +" \""+ t.image+"\"");
	}

}


SKIP :
{
 "--" : COMMENT
|  " "
| "\r"
| "\t"
| "\n"
}

<COMMENT> SKIP : {
  "\n" : DEFAULT
}
<COMMENT> MORE : {
  <~[]>
}

TOKEN : /* Operadores */
{
    <tAND : "and">         {infoLexico(matchedToken,"operador and");}
  | <tOR : "or">     {infoLexico(matchedToken,"operador or");}
  | <tNOT : "not">     {infoLexico(matchedToken,"operador not");}
  | <tMOD : "mod">     {infoLexico(matchedToken,"operador mod");}
  | <tDIV : "div">     {infoLexico(matchedToken,"operador division");}
  | <tMAYOR : ">">     {infoLexico(matchedToken,"operador mayor");}
  | <tMENOR : "<">     {infoLexico(matchedToken,"operador menor");}
  | <tIGUAL : "=">     {infoLexico(matchedToken,"operador igual");}
  | <tMAI : ">=">     {infoLexico(matchedToken,"operador mayor o igual");}
  | <tMEI : "<=">     {infoLexico(matchedToken,"operadormenor o igual");}
  | <tNI : "<>">     {infoLexico(matchedToken,"operador distinto");}
  | <tOPAS : ":=">       {infoLexico(matchedToken,"operador asignacion");}
  | <tSUMA : "+">     {infoLexico(matchedToken,"operador suma");}
  | <tRESTA : "-">     {infoLexico(matchedToken,"operador resta");}
  | <tMUL : "*">     {infoLexico(matchedToken,"operador multiplicacion");}
}

TOKEN : /* Palabras reservadas */
{
<tPROCEDURE : "procedure">      {infoLexico(matchedToken,"procedure");}
    | <tFUNCTION : "function">  {infoLexico(matchedToken,"function");}
    | <tRETURN : "return">      {infoLexico(matchedToken,"return");}
    | <tVAL : "val">            {infoLexico(matchedToken,"valor");}
    | <tREF : "ref">            {infoLexico(matchedToken,"referencia");}
    | <tIS : "is">              {infoLexico(matchedToken,"is");}
    | <tBEGIN : "begin">        {infoLexico(matchedToken,"begin");}
    | <tEND : "end">            {infoLexico(matchedToken,"end");}
    | <tIF : "if">              {infoLexico(matchedToken,"if");}
    | <tTHEN : "then">          {infoLexico(matchedToken,"then");}
    | <tELSE : "else">          {infoLexico(matchedToken,"else");}
    | <tWHILE: "while">        {infoLexico(matchedToken,"while");}
    | <tDO: "do">				{infoLexico(matchedToken,"do");}
    | <tPUT_L : "put_line">     {infoLexico(matchedToken,"put_line");}
    | <tSKIP_L : "skip_line">     {infoLexico(matchedToken,"skip_line");}
    | <tPUT : "put">      {infoLexico(matchedToken,"put");}
    | <tGET : "get">      {infoLexico(matchedToken,"get");}
    | <tINT : "integer">    {infoLexico(matchedToken,"entero");}
    | <tBOOL : "boolean">     {infoLexico(matchedToken,"booleano"); }
    | <tCHAR : "character">   {infoLexico(matchedToken,"caracter");}
    | <tTRUE : "true">      {infoLexico(matchedToken,"true");}
    | <tFALSE : "false">    {infoLexico(matchedToken,"false");}
    | <tINT2CHAR : "int2char">  {infoLexico(matchedToken,"conversion entero-caracter");}
    | <tCHAR2INT : "char2int">  {infoLexico(matchedToken,"conversion caracter-entero");}

}


TOKEN : /*Identificadores*/
{
  <#DIGITO : [ "0"-"9" ]>
|   <#LETRA : [ "a"-"z", "A" -"Z"]>
|   <#BARRA_POR_DELANTE : "_"<LETRA> | "_"<DIGITO>>
                        //[a-z,A-Z]([a-z,A-Z]|_[a-z,A-Z]|_[0-9]|[0-9])*_?|_
|   <tID: <LETRA>(<LETRA> | <BARRA_POR_DELANTE> | <DIGITO>)*("_")? | "_"((<LETRA> | <DIGITO>) (<LETRA> | <BARRA_POR_DELANTE> | <DIGITO>)*("_")?)?>  {infoLexico(matchedToken,"identificador");}

  
}

TOKEN : /* Valores */
{

   <tVALORENTERO : (<DIGITO>)+>                     {infoLexico(matchedToken,"valor entero");}
|   <tVALORBOOLEANO : ("true"| "false")>        {infoLexico(matchedToken,"valor booleano");}
|   <tVALORCHAR : ("'")~["'"]("'")>        {infoLexico(matchedToken,"valor caracter");}
|   <tVALORCADENA : ("\"")(~["\""])*("\"")>  {infoLexico(matchedToken,"valor cadena");}
}


TOKEN : /*Separadores*/
{
  <tPC : ";">                     {infoLexico(matchedToken,"punto y coma");}
| <tCOMA : ",">                   {infoLexico(matchedToken,"coma");}
| <tAP: "(">                      {infoLexico(matchedToken,"abre parentesis");}
| <tCP: ")">                      {infoLexico(matchedToken,"cierro parentesis");}
| <tAV: "[">                      {infoLexico(matchedToken,"abre corchete");}
| <tCV: "]">                      {infoLexico(matchedToken,"cierro corchete");}
}


/*programa ::= <tPROCEDURE> <tID> <tIS> declaracion_variables declaracion_acciones bloque_sentencias <EOF> */
void programa():
{ }
{
  <tPROCEDURE> <tID> <tIS> {tabla_simbolos.insertBlock();} declaracion_variables() declaracion_acciones()  bloque_sentencias() <EOF>
}

/***DECLARACION DE VARIABLES***/
/*declaracion_variables ::= ( declaracion <tPC> )* */
void declaracion_variables():
{}
{
   try {
     ( declaracion() <tPC> )*
 }catch(ParseException e) {
	panic_mode(tPC);
	errorSintactico(e);
 }
}

/*declaracion ::= tipo_variables lista_vars */
void declaracion():
{Symbol.Types tipo_variable;}
{
  try { 
  	tipo_variable = tipo_variables() lista_vars(tipo_variable)
 }catch(ParseException e) {
	errorSintactico(e);
 }
}

/*tipo_variables ::= ( <tINT> | <tCHAR> | <tBOOL> ) */
Symbol.Types tipo_variables():
{}
{
  try { 
  	<tINT>
  	{
  	    return(Symbol.Types.INT);
  	}
  	| <tCHAR>
  	{
  	    return(Symbol.Types.CHAR);
  	}
  	| <tBOOL>
  	{
  	    return(Symbol.Types.BOOL);
  	}
	 }catch(ParseException e) {
	errorSintactico(e);
 }
}
 /*lista_vars := variable ( <tCOMA> variable )* */
 void lista_vars(Symbol.Types tipo_variable):
 {}
 {
   try { 
   variable(tipo_variable) ( <tCOMA> variable(tipo_variable) )*
    }catch(ParseException e) {
	errorSintactico(e);
 }
 }
 
 /*variable := <tID> variable_vector*/
 void variable(Symbol.Types tipo_variable):
 {Token t; int tamanyo_vector = 0;}
 {
   try { 
   t = <tID> (tamanyo_vector = variable_vector())? /*podemos utilizar solo <tAV> <tVALORENTERO> <tCV> */
   {
        try{
            insertar_simbolo_declaracion(tabla_simbolos, t, tipo_variable, tamanyo_vector);
        }catch(AlreadyDefinedSymbolException e){
            System.out.println(e.getMEssage());
        }
   }
 }catch(ParseException e) {
	errorSintactico(e);
 }
 }
 
 /*variable_vector ::= <tAV> <tVALORENTERO> <tCV> | epsilon */
 int variable_vector():
 {Token t;}
 {
   try { 
   <tAV> t = <tVALORENTERO> <tCV>
   {
        return(Integer.parseInt(t.image));
   }
  }catch(ParseException e) {
	errorSintactico(e);
 }
}

/***DECLARACION DE ACCIONES****/
/*declaracion_acciones ::= ( declaracion_accion )* */
void declaracion_acciones() :
{}
{try { 
  (declaracion_accion())*
   }catch(ParseException e) {
	errorSintactico(e);
 }
}

/*declaracion_accion ::= declaracion_funcion | declaracion_proc */
void declaracion_accion() :
{}
{
  try { 
  declaracion_funcion() | declaracion_proc()
   }catch(ParseException e) {
	errorSintactico(e);
 }
}

/*declaracion_funcion ::= cabecera_funcion declaracion_variables bloque_sentencias*/
void declaracion_funcion() :
{}
{
	try { 
  cabecera_funcion() declaracion_variables() bloque_sentencias()
   }catch(ParseException e) {
	errorSintactico(e);
 }
}

/*cabecera_funcion ::= <tFUNCTION> tipo_variables <tID> parametros_formales <tIS>*/
void cabecera_funcion() :
{}
{
  try { 
  <tFUNCTION> tipo_variables() <tID> parametros_formales() <tIS>
   }catch(ParseException e) {
	errorSintactico(e);
 }
}

/*declaracion_proc ::= cabecera_proc declaracion_variables bloque_sentencias*/
void declaracion_proc() :
{}
{ try{
  cabecera_proc() declaracion_variables() bloque_sentencias()
   }catch(ParseException e) {
	errorSintactico(e);
 }
}

/*cabecera_proc ::= <tPROCEDURE> <tID> parametros_formales <tIS>*/
void cabecera_proc() :
{}
{ try{
  <tPROCEDURE> <tID> parametros_formales() <tIS>
   }catch(ParseException e) {
	errorSintactico(e);
 }
}

/*parametros_formales ::= <tAP> ( parametros ( <tPC> parametros )* )? <tCP> */
void parametros_formales() :
{}
{ try{
  <tAP> (parametros() (<tPC> parametros() )* )? <tCP>
 }catch(ParseException e) {
	errorSintactico(e);
 }
}

/*parametros ::= clase_parametros tipo_variables lista_parametros   */
void parametros() :
{}
{ try{
  clase_parametros() tipo_variables() lista_parametros()
 }catch(ParseException e) {
	errorSintactico(e);
 }
}

void clase_parametros() :
{}
{ try{
  <tVAL>
| <tREF>
 }catch(ParseException e) {
	errorSintactico(e);
 }
}

/*lista_parametros ::= parametro lista_parametrosRec*/
void lista_parametros() :
{}
{ try{
  parametro() (<tCOMA> parametro())* /* lista_parametrosRec() */
 }catch(ParseException e) {
	errorSintactico(e);
 }
}


/*parametro := <tID> parametro_vector*/
void parametro() :
{}
{ try{
  <tID> (parametro_vector())?
 }catch(ParseException e) {
	errorSintactico(e);
 }
}

/*parametro_vector ::= <tAV> <tVALORENTERO> <tCV> */
/*IGUAL QUE VARIABLE VECTOR-- ¿ELIMINAR?*/
void parametro_vector() :
{}
{ try{
  <tAV> <tVALORENTERO> <tCV>
 }catch(ParseException e) {
	errorSintactico(e);
 }
}
/***BLOQUE SENTENCIAS**/

/*bloque_sentencias ::= <tBEGIN> lista_sentencias <tEND>*/ 
void bloque_sentencias() :
{}
{ try{
  <tBEGIN> lista_sentencias() <tEND>
   }catch(ParseException e) {
     panic_mode(tEND);
	errorSintactico(e);
 }
}

/*lista_sentencias ::= sentencia**/
void lista_sentencias() :
{}
{ try{
  (sentencia())+ //una o mas sentencias
  |  {}
   }catch(ParseException e) {
	errorSintactico(e);
 }
}

/*lista_sentencias ::= sentencia**/
void sentencia() :
{}
{
  try { 
	  leer() <tPC>
	| skip_linea() <tPC>	 //coge toda la entrada hasta \n
	| escribir() <tPC>
	| escribir_linea() <tPC>
	| LOOKAHEAD(2) invocacion_procedimiento()
	| LOOKAHEAD(2) asignacion() <tPC>
	| declaracion_accion() <tPC>
	| seleccion()
	| mientras_que()
	| <tRETURN> expresion() <tPC>
	}catch(ParseException e) {
	  panic_mode(tPC);
	  errorSintactico(e);
	}
}

void leer() :
{}
{ try{
  <tGET> <tAP> lista_asignables() <tCP>
 }catch(ParseException e) {
	errorSintactico(e);
}
}

/*lista_asignables() := (< tID >) lista_asignablesRec */
void lista_asignables() : //se puede sustituir por variable
{}
{ try{
  <tID> (asignable_vector() )? lista_asignablesRec()
   }catch(ParseException e) {
	errorSintactico(e);
 }
}
/*lista_asignablesRec ::= (asignable_vector)* */
void lista_asignablesRec() : //se puede sustituir por variable
{}
{ try{
  (<tID> (asignable_vector())?)*
 }catch(ParseException e) {
	errorSintactico(e);
 }
}
/*asignable_vector ::= <tAV> expresion <tCV> */
void asignable_vector() :
{}
{ try{
  <tAV> expresion() <tCV>
 }catch(ParseException e) {
	errorSintactico(e);
 }
}

/*skip_linea ::= <tSKIP_L> <tAP> <tCP>*/
void skip_linea() :
{}
{ try{
  <tSKIP_L> <tAP> <tCP>
 }catch(ParseException e) {
	errorSintactico(e);
 }
}

/*escribir ::= <tPUT> <tAP> lista_escribibles <tCP>*/
void escribir() :
{}
{ try{
  <tPUT> <tAP> lista_escribibles() <tCP>
 }catch(ParseException e) {
	errorSintactico(e);
 }
}

/*escribir_linea ::= <tPUT_L> <tAP> lista_escribibles <tCP>*/
void escribir_linea() :
{}
{ try{
  <tPUT_L> <tAP> cero_o_lista_escribibles() <tCP>
  /* Se podria sustituir cero_o_lista_escribibles por (lista_escribibles())* */
 }catch(ParseException e) {
	errorSintactico(e);
 }
}

/*cero_o_lista_escribibles ::= lista_escribibles() | epsilon */
void cero_o_lista_escribibles() :
{}
{ try{
  lista_escribibles()
	| {}
 }catch(ParseException e) {
	errorSintactico(e);
 }

}

/*lista_escribibles ::=   expresion | <tVALORCHAR> | <tVALORCADENA> */
void lista_escribibles() : //1 o mÃ¡s escribibles
{ }

{ try{
  (expresion()) lista_escribiblesRec()
 }catch(ParseException e) {
	errorSintactico(e);
 }
}

/* lista_escribiblesRec ::= (<tCOMA> (expresion | <tVALORCHAR> | <tVALORCADENA> ) )* */
void lista_escribiblesRec() :
{}
{ try{
  (<tCOMA> expresion())*
   }catch(ParseException e) {
	errorSintactico(e);
 }
}

/*asignacion ::= var_asignacion <tOPAS> expresion*/
void asignacion() :
{}
{ try{
  var_asignacion() <tOPAS> expresion()
 }catch(ParseException e) {
	errorSintactico(e);
 }
}

/*var_asignacion ::= <tIDENTIFICADOR> var_Vector*/
void var_asignacion() :
{}
{ try{
  <tID> var_vector()
 }catch(ParseException e) {
	errorSintactico(e);
 }
}

/*var_vector ::= <tAV> expresion <tCV> | epsilon */
void var_vector() :
{}
{ try{
  <tAV> expresion() <tCV>
|
  {} /*epsilon*/
 }catch(ParseException e) {
	errorSintactico(e);
 }
}

/*invocacion_procedimiento ::= <tID> argumentos <tPC> */
void invocacion_procedimiento() : /*IMPORTANTE TIENE QUE SER PROCEDIMIENTO EN EL SEMANTICO*/
{}
{
	  try { 
	  	<tID> argumentos() <tPC>
	  }catch(ParseException e) {
		  panic_mode(tPC);
		  errorSintactico(e);
	  }
}

/*argumentos ::= <tAP> ( lista_expresiones )? <tCP> */
void argumentos() :
{}
{ try{
  <tAP> (lista_expresiones())? <tCP> 
 }catch(ParseException e) {
	errorSintactico(e);
 }
}

/*lista_expresiones ::= expresion (<tCOMA> expresion)* */
void lista_expresiones() :
{}
{ try{
  expresion() (<tCOMA> expresion())*
 }catch(ParseException e) {
	errorSintactico(e);
 }
}

/*seleccion ::= <tIF> expresion <tTHEN> lista_sentencias (<tELSE> lista_sentencias)? <tEND>*/
void seleccion() :
{}
{ 
  try { 
	  <tIF> expresion() <tTHEN> lista_sentencias()
	  (
	    <tELSE> lista_sentencias()
	  )?
	  <tEND> /*REVISAR*/
	}catch(ParseException e) {
	  panic_mode(tEND);
	  errorSintactico(e);
	}
}

/*mientras_que ::= <tWHILE> expresion <tDO> lista_sentencias <tEND>*/
void mientras_que() :
{}
{
  try { 
  	<tWHILE> expresion() <tDO> lista_sentencias() <tEND>
  }catch(ParseException e) {
	  panic_mode(tEND);
	  errorSintactico(e);
  }
}

/*expresion := expresion_simple() (operador_relacional() expresion_simple())?*/
void expresion() :
{}
{ try{
  expresion_simple()
  (
    operador_relacional() expresion_simple()
  )?
   }catch(ParseException e) {
	errorSintactico(e);
 }
}

/*operador_relacional : <tIGUAL> | <tMENOR> | <tMAYOR> | <tMEI> | <tMAI> | <tNI> */
void operador_relacional() :
{}
{ try{
  <tIGUAL>
| <tMENOR>
| <tMAYOR>
| <tMEI>
| <tMAI>
| <tNI>
 }catch(ParseException e) {
	errorSintactico(e);
 }
}

/* expresion_simple : ( <tSUMA> | <tRESTA> )? termino ( operador_aditivo termino )* */
void expresion_simple() :
{}
{ try{
  (<tSUMA> | <tRESTA> )? termino() (operador_aditivo() termino() )*
   }catch(ParseException e) {
	errorSintactico(e);
 }
}

/* operador_aditivo :=  <tSUMA>| <tRESTA>| <tOR>*/ 
void operador_aditivo() :
{}
{ try{
  <tSUMA>
| <tRESTA>
| <tOR>
 }catch(ParseException e) {
	errorSintactico(e);
 }
}

/*termino := factor ( operador_multiplicativo factor )* */
void termino() :
{}
{
  try{
  factor() (operador_multiplicativo() factor() )* 
 }catch(ParseException e) {
	errorSintactico(e);
 }
}

/*operador_multiplicativo :=  <tMUL>| <tMOD>| <tDIV>| <tAND>*/
void operador_multiplicativo() :
{}
{
  try{
  <tMUL>
| <tMOD>
| <tDIV>
| <tAND>
 }catch(ParseException e) {
	errorSintactico(e);
 }
}

/*factor := <tNOT> factor | <tAP> expresion <tCP> | <tINT2CHAR> <tAP> expresion <tCP> | <tCHAR2INT> <tAP> expresion <tCP>
| <tID> accion_o_vector | <tCONST_INT>| <tCONST_CHAR>| <tCONST_STRING>| <tTRUE>| <tFALSE>*/

void factor() :
{}
{
  try{
  <tNOT> factor()
| <tAP> expresion() <tCP>
| <tINT2CHAR> <tAP> expresion() <tCP>
| <tCHAR2INT> <tAP> expresion() <tCP>
| <tID> funcion_o_vector()     /*llamada a funcion o componente de vector*/
| <tVALORENTERO>
| <tVALORCHAR>
| <tVALORCADENA>
| <tTRUE>
| <tFALSE>
 }catch(ParseException e) {
	errorSintactico(e);
 }
}

/*funcion_o_vector := <tAP> lista_cero_o_mas_exps <tCP> | <tAV> expresion <tCV> | /*epsilon* */
void funcion_o_vector() :
{}
{
  try{
  <tAP> (lista_uno_o_mas_exps() )? <tCP> | <tAV> expresion() <tCV> | {} /*epsilon*/
 }catch(ParseException e) {
	errorSintactico(e);
 }
}

/*lista_uno_o_mas_exps:= expresion() (<tCOMA> expresion())* */
void lista_uno_o_mas_exps() :
{}
{
  try{
  expresion() (<tCOMA> expresion() )* 
 }catch(ParseException e) {
	errorSintactico(e);
 }
}


