 options {
   IGNORE_CASE = true;
   COMMON_TOKEN_ACTION = false;

}

PARSER_BEGIN(adac)
package traductor;

public class adac {
	static void errorLexico(Token t) {
		System.out.println("ERROR LÉXICO (" + SimpleCharStream.getBeginLine() +
                ", " + SimpleCharStream.getBeginColumn() + "): símbolo no reconocido: <" +
                SimpleCharStream.GetImage().charAt(adacTokenManager.curLexState) + ">");

	}
  
    public static void main(String[] args) {
    	adac parser;
    	try {
	    	if(args.length == 0) { //entrada desde stdin
				parser = new adac(System.in);
				System.out.println("Leyendo de la entrada estandar...");
			}
			else { //entrada desde fichero en args[0]
	            parser = new adac(new java.io.FileInputStream(args[0])); 
			}
			parser.S(); //invoca simbolo inicial de la gramática
		}
		catch (java.io.FileNotFoundException e) {
			System.err.println ("Fichero " + args[0] + " no encontrado.");
		}
		catch (TokenMgrError e) {
        	errorLexico(token);
        }
        catch (ParseException e) {
        	System.err.println("SINT_ERROR: " + e.getMessage());
        } 
    }
}
PARSER_END(adac)

TOKEN_MGR_DECLS: {
  
static void infoLexico(Token t,String nombre) {
	System.out.println("("+ t.beginLine+","+t.beginColumn+"): " + nombre +" \""+ t.image+"\"");
}


}


SKIP :
{
 "--" : COMMENT
|  " "
| "\r"
| "\t"
| "\n"
}

<COMMENT> SKIP : {
  "\n" : DEFAULT
}
<COMMENT> MORE : {
	<~[]>
}

TOKEN : /* Operadores */
{
    <tAND : "and">         {infoLexico(matchedToken,"operador and");}
  | <tOR : "or">     {infoLexico(matchedToken,"operador or");}
  | <tNOT : "not">     {infoLexico(matchedToken,"operador not");}
  | <tMOD : "mod">     {infoLexico(matchedToken,"operador mod");}
  | <tDIV : "div">     {infoLexico(matchedToken,"operador division");}
  | <tMAYOR : ">">     {infoLexico(matchedToken,"operador mayor");}
  | <tMENOR : "<">     {infoLexico(matchedToken,"operador menor");}
  | <tIGUAL : "=">     {infoLexico(matchedToken,"operador igual");}
  | <tMAI : ">=">     {infoLexico(matchedToken,"operador mayor o igual");}
  | <tMEI : "<=">     {infoLexico(matchedToken,"operadormenor o igual");}
  | <tNI : "<>">     {infoLexico(matchedToken,"operador distinto");}
  | <tOPAS : ":=">       {infoLexico(matchedToken,"operador asignacion");}
  | <tSUMA : "+">     {infoLexico(matchedToken,"operador suma");}
  | <tRESTA : "-">     {infoLexico(matchedToken,"operador resta");}
  | <tMUL : "*">     {infoLexico(matchedToken,"operador multiplicacion");}
}

TOKEN : /* Palabras reservadas */
{
<tPROCEDURE : "procedure">      {infoLexico(matchedToken,"procedure");}
    | <TFUNCTION : "function">  {infoLexico(matchedToken,"function");}
    | <tRETURN : "return">      {infoLexico(matchedToken,"return");}
    | <tVAR : "var">            {infoLexico(matchedToken,"variable");}
    | <tREF : "ref">            {infoLexico(matchedToken,"referencia");}
    | <tIS : "is">              {infoLexico(matchedToken,"is");}
    | <tBEGIN : "begin">        {infoLexico(matchedToken,"begin");}
    | <tEND : "end">            {infoLexico(matchedToken,"end");}
    | <tIF : "if">              {infoLexico(matchedToken,"if");}
    | <tTHEN : "then">          {infoLexico(matchedToken,"then");}
    | <tELSE : "else">          {infoLexico(matchedToken,"else");}
    | <tWHILE: "while" >        {infoLexico(matchedToken,"while");}
    | <tPUT_L : "put_line">     {infoLexico(matchedToken,"put_line");}
  	| <tPUT : "put">			{infoLexico(matchedToken,"put");}
  	| <tGET : "get">			{infoLexico(matchedToken,"get");}
  	| <tINT : "integer">		{infoLexico(matchedToken,"entero");}
  	| <tBOOL : "boolean"> 		{infoLexico(matchedToken,"booleano"); }
  	| <tCHAR : "character"> 	{infoLexico(matchedToken,"caracter");}
  	| <tTRUE : "true"> 			{infoLexico(matchedToken,"true");}
  	| <tFALSE : "false"> 		{infoLexico(matchedToken,"false");}
  	| <tINT2CHAR : "int2char">	{infoLexico(matchedToken,"conversion entero-caracter");}

}


TOKEN : /*Identificadores*/
{
	< #DIGITO : [ "0"-"9" ] >
| 	< #LETRA : [ "a"-"z", "A" -"Z"] >
|   < #BARRA_POR_DELANTE : "_"< LETRA > | "_"< DIGITO > >
                        //[a-z,A-Z]([a-z,A-Z]|_[a-z,A-Z]|_[0-9]|[0-9])*_?|_
| 	< tIDENTIFICADOR: < LETRA >(< LETRA > | < BARRA_POR_DELANTE > | < DIGITO >)*("_")? |
"_"((< LETRA > | < DIGITO >) (< LETRA > | < BARRA_POR_DELANTE > | < DIGITO >)*("_")?)? > 	{infoLexico(matchedToken,"identificador");}

  
}

TOKEN : /* Valores */
{

   < tVALORENTERO : (< DIGITO >)+ >                     {infoLexico(matchedToken,"valor entero");}
|   < tVALORBOOLEANO : ("true"| "false") >				{infoLexico(matchedToken,"valor booleano");}
| 	< tVALORCHAR : ("\"")~["\""]("\"") >				{infoLexico(matchedToken,"valor caracter");}
| 	< tVALORCADENA : ("\"")~["\""](~["\""])+("\"") >	{infoLexico(matchedToken,"valor cadena");}
}


TOKEN : /*Separadores*/
{
  < tPC : ";" >                     {infoLexico(matchedToken,"punto y coma");}
| < tCOMA : "," >                   {infoLexico(matchedToken,"coma");}
| < tAP: "(" >                      {infoLexico(matchedToken,"abre parentesis");}
| < tCP: ")" >                      {infoLexico(matchedToken,"cierro parentesis");}
| < tAV: "[" >                      {infoLexico(matchedToken,"abre corchete");}
| < tCV: "]" >                      {infoLexico(matchedToken,"cierro corchete");}
}





void S () : 
{

}
{

  (
    < tAND >
  | < tOR >
  | < tNOT >
  | < tMOD >
  | < tDIV >
  | < tMAYOR >
  | < tMENOR >
  | < tIGUAL >
  | < tMAI >
  | < tMEI >
  | < tNI >
  | < tOPAS >
  | < tSUMA >
  | < tRESTA >
  | < tMUL >
  | < tPROCEDURE >
  | < TFUNCTION >
  | < tRETURN >
  | < tVAR >
  | < tREF >
  | < tIS >
  | < tBEGIN >
  | < tEND >
  | < tIF >
  | < tTHEN >
  | < tELSE >
  | < tWHILE >
  | < tPUT_L >
  | < tPUT >
  | < tGET >
  | < tINT >
  | < tBOOL >
  | < tCHAR >
  | < tTRUE >
  | < tFALSE >
  | < tINT2CHAR >
  | < tIDENTIFICADOR >
  | < tVALORENTERO >
  | < tVALORBOOLEANO >
  | < tVALORCHAR >
  | < tVALORCADENA >
  | < tPC >
  | < tCOMA >
  | < tAP > 
  | < tCP > 
  | < tAV > 
  | < tCV > 

	)+
	< EOF >
}


