 options {
   IGNORE_CASE = true;
   COMMON_TOKEN_ACTION = false;
   DEBUG_PARSER = false;
}

PARSER_BEGIN(adac)
package traductor;

public class adac {
  static void errorLexico(Token t) {
    System.out.println("ERROR LÉXICO (" + SimpleCharStream.getBeginLine() +
                ", " + SimpleCharStream.getBeginColumn() + "): símbolo no reconocido: <" +
                SimpleCharStream.GetImage().charAt(adacTokenManager.curLexState) + ">");

  }
  
    public static void main(String[] args) {
      adac parser;
      try {
        if(args.length == 0) { //entrada desde stdin
        parser = new adac(System.in);
        System.out.println("Leyendo de la entrada estandar...");
      }
      else { //entrada desde fichero en args[0]
              parser = new adac(new java.io.FileInputStream(args[0])); 
      }
      parser.programa(); //invoca simbolo inicial de la gramÃƒÆ’Ã‚Â¡tica
    }
    catch (java.io.FileNotFoundException e) {
      System.err.println ("Fichero " + args[0] + " no encontrado.");
    }
    catch (TokenMgrError e) {
          errorLexico(token);
        }
        catch (ParseException e) {
          System.err.println("SINT_ERROR: " + e.getMessage());
        } 
    }
}
PARSER_END(adac)

TOKEN_MGR_DECLS: {
  
static void infoLexico(Token t,String nombre) {
  System.out.println("("+ t.beginLine+","+t.beginColumn+"): " + nombre +" \""+ t.image+"\"");
}


}


SKIP :
{
 "--" : COMMENT
|  " "
| "\r"
| "\t"
| "\n"
}

<COMMENT> SKIP : {
  "\n" : DEFAULT
}
<COMMENT> MORE : {
  <~[]>
}

TOKEN : /* Operadores */
{
    <tAND : "and">         {infoLexico(matchedToken,"operador and");}
  | <tOR : "or">     {infoLexico(matchedToken,"operador or");}
  | <tNOT : "not">     {infoLexico(matchedToken,"operador not");}
  | <tMOD : "mod">     {infoLexico(matchedToken,"operador mod");}
  | <tDIV : "div">     {infoLexico(matchedToken,"operador division");}
  | <tMAYOR : ">">     {infoLexico(matchedToken,"operador mayor");}
  | <tMENOR : "<">     {infoLexico(matchedToken,"operador menor");}
  | <tIGUAL : "=">     {infoLexico(matchedToken,"operador igual");}
  | <tMAI : ">=">     {infoLexico(matchedToken,"operador mayor o igual");}
  | <tMEI : "<=">     {infoLexico(matchedToken,"operadormenor o igual");}
  | <tNI : "<>">     {infoLexico(matchedToken,"operador distinto");}
  | <tOPAS : ":=">       {infoLexico(matchedToken,"operador asignacion");}
  | <tSUMA : "+">     {infoLexico(matchedToken,"operador suma");}
  | <tRESTA : "-">     {infoLexico(matchedToken,"operador resta");}
  | <tMUL : "*">     {infoLexico(matchedToken,"operador multiplicacion");}
}

TOKEN : /* Palabras reservadas */
{
<tPROCEDURE : "procedure">      {infoLexico(matchedToken,"procedure");}
    | <tFUNCTION : "function">  {infoLexico(matchedToken,"function");}
    | <tRETURN : "return">      {infoLexico(matchedToken,"return");}
    | <tVAL : "val">            {infoLexico(matchedToken,"valor");}
    | <tREF : "ref">            {infoLexico(matchedToken,"referencia");}
    | <tIS : "is">              {infoLexico(matchedToken,"is");}
    | <tBEGIN : "begin">        {infoLexico(matchedToken,"begin");}
    | <tEND : "end">            {infoLexico(matchedToken,"end");}
    | <tIF : "if">              {infoLexico(matchedToken,"if");}
    | <tTHEN : "then">          {infoLexico(matchedToken,"then");}
    | <tELSE : "else">          {infoLexico(matchedToken,"else");}
    | <tWHILE: "while">        {infoLexico(matchedToken,"while");}
    | <tDO: "do">				{infoLexico(matchedToken,"do");}
    | <tPUT_L : "put_line">     {infoLexico(matchedToken,"put_line");}
    | <tSKIP_L : "skip_line">     {infoLexico(matchedToken,"skip_line");}
    | <tPUT : "put">      {infoLexico(matchedToken,"put");}
    | <tGET : "get">      {infoLexico(matchedToken,"get");}
    | <tINT : "integer">    {infoLexico(matchedToken,"entero");}
    | <tBOOL : "boolean">     {infoLexico(matchedToken,"booleano"); }
    | <tCHAR : "character">   {infoLexico(matchedToken,"caracter");}
    | <tTRUE : "true">      {infoLexico(matchedToken,"true");}
    | <tFALSE : "false">    {infoLexico(matchedToken,"false");}
    | <tINT2CHAR : "int2char">  {infoLexico(matchedToken,"conversion entero-caracter");}
    | <tCHAR2INT : "char2int">  {infoLexico(matchedToken,"conversion caracter-entero");}

}


TOKEN : /*Identificadores*/
{
  <#DIGITO : [ "0"-"9" ]>
|   <#LETRA : [ "a"-"z", "A" -"Z"]>
|   <#BARRA_POR_DELANTE : "_"<LETRA> | "_"<DIGITO>>
                        //[a-z,A-Z]([a-z,A-Z]|_[a-z,A-Z]|_[0-9]|[0-9])*_?|_
|   <tID: <LETRA>(<LETRA> | <BARRA_POR_DELANTE> | <DIGITO>)*("_")? | "_"((<LETRA> | <DIGITO>) (<LETRA> | <BARRA_POR_DELANTE> | <DIGITO>)*("_")?)?>  {infoLexico(matchedToken,"identificador");}

  
}

TOKEN : /* Valores */
{

   <tVALORENTERO : (<DIGITO>)+>                     {infoLexico(matchedToken,"valor entero");}
|   <tVALORBOOLEANO : ("true"| "false")>        {infoLexico(matchedToken,"valor booleano");}
|   <tVALORCHAR : ("'")~["'"]("'")>        {infoLexico(matchedToken,"valor caracter");}
|   <tVALORCADENA : ("\"")(~["\""])*("\"")>  {infoLexico(matchedToken,"valor cadena");}
}


TOKEN : /*Separadores*/
{
  <tPC : ";">                     {infoLexico(matchedToken,"punto y coma");}
| <tCOMA : ",">                   {infoLexico(matchedToken,"coma");}
| <tAP: "(">                      {infoLexico(matchedToken,"abre parentesis");}
| <tCP: ")">                      {infoLexico(matchedToken,"cierro parentesis");}
| <tAV: "[">                      {infoLexico(matchedToken,"abre corchete");}
| <tCV: "]">                      {infoLexico(matchedToken,"cierro corchete");}
}


/*programa ::= <tPROCEDURE> <tID> <tIS> declaracion_variables declaracion_acciones bloque_sentencias <EOF> */
void programa():
{ }
{
  <tPROCEDURE> <tID> <tIS> declaracion_variables() declaracion_acciones()  bloque_sentencias() <EOF>
}

/***DECLARACION DE VARIABLES***/
/*declaracion_variables ::= ( declaracion <tPC> )* */
void declaracion_variables():
{}
{
   ( declaracion() <tPC> )*
}

/*declaracion ::= tipo_variables lista_vars */
void declaracion():
{}
{
  tipo_variables() lista_vars()
}

/*tipo_variables ::= ( <tINT> | <tCHAR> | <tBOOL> ) */
void tipo_variables():
{}
{
   <tINT> | <tCHAR> | <tBOOL>
}
 /*lista_vars := variable ( <tCOMA> variable )* */
 void lista_vars():
 {}
 {
   variable() ( <tCOMA> variable() )*
 }
 
 /*variable := <tID> variable_vector*/
 void variable():
 {}
 {
   <tID> (variable_vector())? /*podemos utilizar solo <tAV> <tVALORENTERO> <tCV> */
 }
 
 /*variable_vector ::= <tAV> <tVALORENTERO> <tCV> | epsilon */
 void variable_vector():
 {}
 {
   <tAV> <tVALORENTERO> <tCV>
}

/***DECLARACION DE ACCIONES****/
/*declaracion_acciones ::= ( declaracion_accion )* */
void declaracion_acciones() :
{}
{
  (declaracion_accion())*
}

/*declaracion_accion ::= declaracion_funcion | declaracion_proc */
void declaracion_accion() :
{}
{
  declaracion_funcion() | declaracion_proc()
}

/*declaracion_funcion ::= cabecera_funcion declaracion_variables bloque_sentencias*/
void declaracion_funcion() :
{}
{
  cabecera_funcion() declaracion_variables() bloque_sentencias()
}

/*cabecera_funcion ::= <tFUNCTION> tipo_variables <tID> parametros_formales <tIS>*/
void cabecera_funcion() :
{}
{
  <tFUNCTION> tipo_variables() <tID> parametros_formales() <tIS>
}

/*declaracion_proc ::= cabecera_proc declaracion_variables bloque_sentencias*/
void declaracion_proc() :
{}
{
  cabecera_proc() declaracion_variables() bloque_sentencias()
}

/*cabecera_proc ::= <tPROCEDURE> <tID> parametros_formales <tIS>*/
void cabecera_proc() :
{}
{
  <tPROCEDURE> <tID> parametros_formales() <tIS>
}

/*parametros_formales ::= <tAP> ( parametros ( <tPC> parametros )* )? <tCP> */
void parametros_formales() :
{}
{
  <tAP> (parametros() (<tPC> parametros() )* )? <tCP>
}

/*parametros ::= clase_parametros tipo_variables lista_parametros   */
void parametros() :
{}
{
  clase_parametros() tipo_variables() lista_parametros()
}

void clase_parametros() :
{}
{
  <tVAL>
| <tREF>
}

/*lista_parametros ::= parametro lista_parametrosRec*/
void lista_parametros() :
{}
{
  parametro() (<tCOMA> parametro())* /* lista_parametrosRec() */
}

/*lista_parametrosRec ::=  ( <tCOMA> parametro )* 
void lista_parametrosRec() :
{}
{
  (<tCOMA> parametro())*
}
*/

/*parametro := <tID> parametro_vector*/
void parametro() :
{}
{
  <tID> (parametro_vector())?
}

/*parametro_vector ::= <tAV> <tVALORENTERO> <tCV> */
/*IGUAL QUE VARIABLE VECTOR-- Â¿ELIMINAR?*/
void parametro_vector() :
{}
{
  <tAV> <tVALORENTERO> <tCV>
}
/***BLOQUE SENTENCIAS**/

/*bloque_sentencias ::= <tBEGIN> lista_sentencias <tEND>*/
void bloque_sentencias() :
{}
{
  <tBEGIN> lista_sentencias() <tEND>
}

/*lista_sentencias ::= sentencia**/
void lista_sentencias() :
{}
{
  (sentencia())+ //una o mas sentencias
|
  {}
}

/*lista_sentencias ::= sentencia**/
void sentencia() :
{}
{
  leer() <tPC>
| skip_linea() <tPC>	 //coge toda la entrada hasta \n
| escribir() <tPC>
| escribir_linea() <tPC>
| LOOKAHEAD(2) invocacion_procedimiento()
| LOOKAHEAD(2) asignacion() <tPC>
| seleccion()
| mientras_que()
| <tRETURN> expresion() <tPC>
}

void leer() :
{}
{
  <tGET> <tAP> lista_asignables() <tCP>
}

/*lista_asignables() := (< tID >) lista_asignablesRec */
void lista_asignables() : //se puede sustituir por variable
{}
{
  <tID> (asignable_vector() )? lista_asignablesRec()
}
/*lista_asignablesRec ::= (asignable_vector)* */
void lista_asignablesRec() : //se puede sustituir por variable
{}
{
  (<tID> (asignable_vector())?)*
}
/*asignable_vector ::= <tAV> expresion <tCV> */
void asignable_vector() :
{}
{
  <tAV> expresion() <tCV>
}

/*skip_linea ::= <tSKIP_L> <tAP> <tCP>*/
void skip_linea() :
{}
{
  <tSKIP_L> <tAP> <tCP>
}

/*escribir ::= <tPUT> <tAP> lista_escribibles <tCP>*/
void escribir() :
{}
{
  <tPUT> <tAP> lista_escribibles() <tCP>
}

/*escribir_linea ::= <tPUT_L> <tAP> lista_escribibles <tCP>*/
void escribir_linea() :
{}
{
  <tPUT_L> <tAP> cero_o_lista_escribibles() <tCP>
  /* Se podria sustituir cero_o_lista_escribibles por (lista_escribibles())* */
}

/*cero_o_lista_escribibles ::= lista_escribibles() | epsilon */
void cero_o_lista_escribibles() :
{}
{
  lista_escribibles()
| {}
/*DEFINIR CADENA VACIA*/

}

/*lista_escribibles ::=   expresion | <tVALORCHAR> | <tVALORCADENA> */
void lista_escribibles() : //1 o mÃƒÂ¡s escribibles
{}
{
  (expresion()) lista_escribiblesRec()
}

/* lista_escribiblesRec ::= (<tCOMA> (expresion | <tVALORCHAR> | <tVALORCADENA> ) )* */
void lista_escribiblesRec() :
{}
{
  (<tCOMA> expresion())*
}

/*asignacion ::= var_asignacion <tOPAS> expresion*/
void asignacion() :
{}
{
  var_asignacion() <tOPAS> expresion()
}

/*var_asignacion ::= <tIDENTIFICADOR> var_Vector*/
void var_asignacion() :
{}
{
  <tID> var_vector()
}

/*var_vector ::= <tAV> expresion <tCV> | epsilon */
void var_vector() :
{}
{
  <tAV> expresion() <tCV>
|
  {} /*epsilon*/
}

/*invocacion_procedimiento ::= <tID> argumentos <tPC> */
void invocacion_procedimiento() : /*IMPORTANTE TIENE QUE SER PROCEDIMIENTO EN EL SEMANTICO*/
{}
{
  <tID> argumentos() <tPC>
}

/*argumentos ::= <tAP> ( lista_expresiones )? <tCP> */
void argumentos() :
{}
{
  <tAP> (lista_expresiones())? <tCP> 
}

/*lista_expresiones ::= expresion (<tCOMA> expresion)* */
void lista_expresiones() :
{}
{
  expresion() (<tCOMA> expresion())*
}

/*seleccion ::= <tIF> expresion <tTHEN> lista_sentencias (<tELSE> lista_sentencias)? <tEND>*/
void seleccion() :
{}
{
  <tIF> expresion() <tTHEN> lista_sentencias()
  (
    <tELSE> lista_sentencias()
  )?
  <tEND> /*REVISAR*/
}

/*mientras_que ::= <tWHILE> expresion <tDO> lista_sentencias <tEND>*/
void mientras_que() :
{}
{
  <tWHILE> expresion() <tDO> lista_sentencias() <tEND>
}

/*expresion := expresion_simple() (operador_relacional() expresion_simple())?*/
void expresion() :
{}
{
  expresion_simple()
  (
    operador_relacional() expresion_simple()
  )?
}

/*operador_relacional : <tIGUAL> | <tMENOR> | <tMAYOR> | <tMEI> | <tMAI> | <tNI> */
void operador_relacional() :
{}
{
  <tIGUAL>
| <tMENOR>
| <tMAYOR>
| <tMEI>
| <tMAI>
| <tNI>
}

/* expresion_simple : ( <tSUMA> | <tRESTA> )? termino ( operador_aditivo termino )* */
void expresion_simple() :
{}
{
  (<tSUMA> | <tRESTA> )? termino() (operador_aditivo() termino() )*
}

/* operador_aditivo :=  <tSUMA>| <tRESTA>| <tOR>*/ 
void operador_aditivo() :
{}
{
  <tSUMA>
| <tRESTA>
| <tOR>
}

/*termino := factor ( operador_multiplicativo factor )* */
void termino() :
{}
{
  factor() (operador_multiplicativo() factor() )* 
}

/*operador_multiplicativo :=  <tMUL>| <tMOD>| <tDIV>| <tAND>*/
void operador_multiplicativo() :
{}
{
  <tMUL>
| <tMOD>
| <tDIV>
| <tAND>
}

/*factor := <tNOT> factor
| <tAP> expresion <tCP>
| <tINT2CHAR> <tAP> expresion <tCP>
| <tCHAR2INT> <tAP> expresion <tCP>
| <tID> accion_o_vector
| <tCONST_INT>
| <tCONST_CHAR>
| <tCONST_STRING>
| <tTRUE>
| <tFALSE>
*/

void factor() :
{}
{
  <tNOT> factor()
| <tAP> expresion() <tCP>
| <tINT2CHAR> <tAP> expresion() <tCP>
| <tCHAR2INT> <tAP> expresion() <tCP>
| <tID> funcion_o_vector()     /*llamada a funcion o componente de vector*/
| <tVALORENTERO>
| <tVALORCHAR>
| <tVALORCADENA>
| <tTRUE>
| <tFALSE>
}

/*funcion_o_vector := <tAP> lista_cero_o_mas_exps <tCP> | <tAV> expresion <tCV> | /*epsilon* */
void funcion_o_vector() :
{}
{
  <tAP> (lista_uno_o_mas_exps() )? <tCP> | <tAV> expresion() <tCV> | {} /*epsilon*/
}

/*lista_uno_o_mas_exps:= expresion() (<tCOMA> expresion())* */
void lista_uno_o_mas_exps() :
{}
{
  expresion() (<tCOMA> expresion() )* 
}


/*
void S () : 
{

}
{

  (
    <tAND>
  | <tOR>
  | <tNOT>
  | <tMOD>
  | <tDIV>
  | <tMAYOR>
  | <tMENOR>
  | <tIGUAL>
  | <tMAI>
  | <tMEI>
  | <tNI>
  | <tOPAS>
  | <tSUMA>
  | <tRESTA>
  | <tMUL>
  | <tPROCEDURE>
  | <TFUNCTION>
  | <tRETURN>
  | <tVAL>
  | <tREF>
  | <tIS>
  | <tBEGIN>
  | <tEND>
  | <tIF>
  | <tTHEN>
  | <tELSE>
  | <tWHILE>
  | <tPUT_L>
  | <tPUT>
  | <tGET>
  | <tINT>
  | <tBOOL>
  | <tCHAR>
  | <tTRUE>
  | <tFALSE>
  | <tINT2CHAR>
  | <tID>
  | <tVALORENTERO>
  | <tVALORBOOLEANO>
  | <tVALORCHAR>
  | <tVALORCADENA>
  | <tPC>
  | <tCOMA>
  | <tAP> 
  | <tCP> 
  | <tAV> 
  | <tCV> 

  )+
  <EOF>
}
*/

